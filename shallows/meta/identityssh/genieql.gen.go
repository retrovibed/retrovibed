//go:build !genieql.ignore
// +build !genieql.ignore

package identityssh

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ identityssh/10_generate.genieql.go line 3

// Identity generated by genieql
type Identity struct {
	CreatedAt  time.Time `json:"created_at"`
	DisabledAt time.Time `json:"disabled_at"`
	ID         string    `json:"id"`
	ProfileID  string    `json:"profile_id"`
	PublicKey  string    `json:"public_key"`
	UpdatedAt  time.Time `json:"updated_at"`
}

// IdentityScanner scanner interface.
type IdentityScanner interface {
	Scan(i *Identity) error
	Next() bool
	Close() error
	Err() error
}

type errIdentityScanner struct {
	e error
}

func (t errIdentityScanner) Scan(i *Identity) error {
	return t.e
}

func (t errIdentityScanner) Next() bool {
	return false
}

func (t errIdentityScanner) Err() error {
	return t.e
}

func (t errIdentityScanner) Close() error {
	return nil
}

// IdentityScannerStaticColumns generated by genieql
const IdentityScannerStaticColumns = `meta_sso_identity_ssh."created_at",meta_sso_identity_ssh."disabled_at",meta_sso_identity_ssh."id",meta_sso_identity_ssh."profile_id",meta_sso_identity_ssh."public_key",meta_sso_identity_ssh."updated_at"`

// NewIdentityScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewIdentityScannerStatic(rows *sql.Rows, err error) IdentityScanner {
	if err != nil {
		return errIdentityScanner{e: err}
	}

	return identityScannerStatic{
		Rows: rows,
	}
}

// identityScannerStatic generated by genieql
type identityScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t identityScannerStatic) Scan(i *Identity) error {
	var (
		c0 sql.NullTime
		c1 sql.NullTime
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullString
		c5 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := c1.Time
		i.DisabledAt = tmp
	}

	if c2.Valid {
		if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ProfileID = uid.String()
		}
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.PublicKey = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t identityScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t identityScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t identityScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewIdentityScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewIdentityScannerStaticRow(row *sql.Row) IdentityScannerStaticRow {
	return IdentityScannerStaticRow{
		row: row,
	}
}

// IdentityScannerStaticRow generated by genieql
type IdentityScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t IdentityScannerStaticRow) Scan(i *Identity) error {
	var (
		c0 sql.NullTime
		c1 sql.NullTime
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullString
		c5 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := c1.Time
		i.DisabledAt = tmp
	}

	if c2.Valid {
		if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ProfileID = uid.String()
		}
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.PublicKey = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t IdentityScannerStaticRow) Err(err error) IdentityScannerStaticRow {
	t.err = err
	return t
}

// NewIdentityScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewIdentityScannerDynamic(rows *sql.Rows, err error) IdentityScanner {
	if err != nil {
		return errIdentityScanner{e: err}
	}

	return identityScannerDynamic{
		Rows: rows,
	}
}

// identityScannerDynamic generated by genieql
type identityScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t identityScannerDynamic) Scan(i *Identity) error {
	const (
		cn0 = "created_at"
		cn1 = "disabled_at"
		cn2 = "id"
		cn3 = "profile_id"
		cn4 = "public_key"
		cn5 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullTime
		c2      sql.NullString
		c3      sql.NullString
		c4      sql.NullString
		c5      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				i.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := c1.Time
				i.DisabledAt = tmp
			}

		case cn2:
			if c2.Valid {
				if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn3:
			if c3.Valid {
				if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
					return err
				} else {
					i.ProfileID = uid.String()
				}
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.PublicKey = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := c5.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t identityScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t identityScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t identityScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// IdentityFindByCreatedAt generated by genieql
func IdentityFindByCreatedAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) IdentityScannerStaticRow {
	const query = `SELECT "created_at","disabled_at","id","profile_id","public_key","updated_at" FROM "meta_sso_identity_ssh" WHERE "created_at" = $1`
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// IdentityFindByDisabledAt generated by genieql
func IdentityFindByDisabledAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) IdentityScannerStaticRow {
	const query = `SELECT "created_at","disabled_at","id","profile_id","public_key","updated_at" FROM "meta_sso_identity_ssh" WHERE "disabled_at" = $1`
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// IdentityFindByID generated by genieql
func IdentityFindByID(ctx context.Context, q sqlx.Queryer, c sql.NullString) IdentityScannerStaticRow {
	const query = `SELECT "created_at","disabled_at","id","profile_id","public_key","updated_at" FROM "meta_sso_identity_ssh" WHERE "id" = $1`
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// IdentityFindByProfileID generated by genieql
func IdentityFindByProfileID(ctx context.Context, q sqlx.Queryer, c sql.NullString) IdentityScannerStaticRow {
	const query = `SELECT "created_at","disabled_at","id","profile_id","public_key","updated_at" FROM "meta_sso_identity_ssh" WHERE "profile_id" = $1`
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// IdentityFindByPublicKey generated by genieql
func IdentityFindByPublicKey(ctx context.Context, q sqlx.Queryer, c sql.NullString) IdentityScannerStaticRow {
	const query = `SELECT "created_at","disabled_at","id","profile_id","public_key","updated_at" FROM "meta_sso_identity_ssh" WHERE "public_key" = $1`
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// IdentityFindByUpdatedAt generated by genieql
func IdentityFindByUpdatedAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) IdentityScannerStaticRow {
	const query = `SELECT "created_at","disabled_at","id","profile_id","public_key","updated_at" FROM "meta_sso_identity_ssh" WHERE "updated_at" = $1`
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// IdentityInsertWithDefaultsStaticColumns generated by genieql
const IdentityInsertWithDefaultsStaticColumns = `DEFAULT,$1,$2,$3,$4,DEFAULT`

// IdentityInsertWithDefaultsExplode generated by genieql
func IdentityInsertWithDefaultsExplode(a *Identity) ([]interface{}, error) {
	var (
		c0 sql.NullTime   // disabled_at
		c1 sql.NullString // id
		c2 sql.NullString // profile_id
		c3 sql.NullString // public_key
	)

	c0.Valid = true
	c0.Time = a.DisabledAt

	c1.Valid = true
	c1.String = a.ID

	c2.Valid = true
	c2.String = a.ProfileID

	c3.Valid = true
	c3.String = a.PublicKey

	return []interface{}{c0, c1, c2, c3}, nil
}

// IdentityInsertWithDefaults generated by genieql
func IdentityInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Identity) IdentityScannerStaticRow {
	const query = `INSERT INTO "meta_sso_identity_ssh" ("created_at","disabled_at","id","profile_id","public_key","updated_at") VALUES (DEFAULT,$1,$2,$3,$4,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "created_at","disabled_at","id","profile_id","public_key","updated_at"`
	var (
		c0 sql.NullTime   // disabled_at
		c1 sql.NullString // id
		c2 sql.NullString // profile_id
		c3 sql.NullString
	)
	c0.Valid = true
	c0.Time = a.DisabledAt
	c1.Valid = true
	c1.String = a.ID
	c2.Valid = true
	c2.String = a.ProfileID
	c3.Valid = true
	c3.String = a.PublicKey // public_key
	return NewIdentityScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3))
}
