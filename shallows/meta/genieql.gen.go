//go:build !genieql.ignore
// +build !genieql.ignore

package meta

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ meta/10_generate.genieql.go line 3

// Profile generated by genieql
type Profile struct {
	CreatedAt                 time.Time `json:"created_at"`
	Description               string    `json:"description"`
	DisabledAt                time.Time `json:"disabled_at"`
	DisabledManuallyAt        time.Time `json:"disabled_manually_at"`
	DisabledPendingApprovalAt time.Time `json:"disabled_pending_approval_at"`
	ID                        string    `json:"id"`
	SessionWatermark          string    `json:"session_watermark"`
	UpdatedAt                 time.Time `json:"updated_at"`
}

// Daemon generated by genieql
type Daemon struct {
	CreatedAt   time.Time `json:"created_at"`
	Description string    `json:"description"`
	Hostname    string    `json:"hostname"`
	ID          string    `json:"id"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ConsumedToken generated by genieql
type ConsumedToken struct {
	CreatedAt    time.Time `json:"created_at"`
	ID           string    `json:"id"`
	Token        string    `json:"token"`
	TombstonedAt time.Time `json:"tombstoned_at"`
}

// Authz generated by genieql
type Authz struct {
	CreatedAt      time.Time `json:"created_at"`
	ID             string    `json:"id"`
	ProfileID      string    `json:"profile_id"`
	UpdatedAt      time.Time `json:"updated_at"`
	Usermanagement bool      `json:"usermanagement"`
}

// ProfileScanner scanner interface.
type ProfileScanner interface {
	Scan(i *Profile) error
	Next() bool
	Close() error
	Err() error
}

type errProfileScanner struct {
	e error
}

func (t errProfileScanner) Scan(i *Profile) error {
	return t.e
}

func (t errProfileScanner) Next() bool {
	return false
}

func (t errProfileScanner) Err() error {
	return t.e
}

func (t errProfileScanner) Close() error {
	return nil
}

// ProfileScannerStaticColumns generated by genieql
const ProfileScannerStaticColumns = `meta_profiles."created_at",meta_profiles."description",meta_profiles."disabled_at",meta_profiles."disabled_manually_at",meta_profiles."disabled_pending_approval_at",meta_profiles."id",meta_profiles."session_watermark",meta_profiles."updated_at"`

// NewProfileScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewProfileScannerStatic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerStatic{
		Rows: rows,
	}
}

// profileScannerStatic generated by genieql
type profileScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t profileScannerStatic) Scan(i *Profile) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullTime
		c3 sql.NullTime
		c4 sql.NullTime
		c5 sql.NullString
		c6 sql.NullString
		c7 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := c2.Time
		i.DisabledAt = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.DisabledManuallyAt = tmp
	}

	if c4.Valid {
		tmp := c4.Time
		i.DisabledPendingApprovalAt = tmp
	}

	if c5.Valid {
		if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.SessionWatermark = uid.String()
		}
	}

	if c7.Valid {
		tmp := c7.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t profileScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t profileScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t profileScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewProfileScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewProfileScannerStaticRow(row *sql.Row) ProfileScannerStaticRow {
	return ProfileScannerStaticRow{
		row: row,
	}
}

// ProfileScannerStaticRow generated by genieql
type ProfileScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ProfileScannerStaticRow) Scan(i *Profile) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullTime
		c3 sql.NullTime
		c4 sql.NullTime
		c5 sql.NullString
		c6 sql.NullString
		c7 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := c2.Time
		i.DisabledAt = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.DisabledManuallyAt = tmp
	}

	if c4.Valid {
		tmp := c4.Time
		i.DisabledPendingApprovalAt = tmp
	}

	if c5.Valid {
		if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.SessionWatermark = uid.String()
		}
	}

	if c7.Valid {
		tmp := c7.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t ProfileScannerStaticRow) Err(err error) ProfileScannerStaticRow {
	t.err = err
	return t
}

// NewProfileScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewProfileScannerDynamic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerDynamic{
		Rows: rows,
	}
}

// profileScannerDynamic generated by genieql
type profileScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t profileScannerDynamic) Scan(i *Profile) error {
	const (
		cn0 = "created_at"
		cn1 = "description"
		cn2 = "disabled_at"
		cn3 = "disabled_manually_at"
		cn4 = "disabled_pending_approval_at"
		cn5 = "id"
		cn6 = "session_watermark"
		cn7 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullString
		c2      sql.NullTime
		c3      sql.NullTime
		c4      sql.NullTime
		c5      sql.NullString
		c6      sql.NullString
		c7      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				i.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.Description = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := c2.Time
				i.DisabledAt = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.DisabledManuallyAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := c4.Time
				i.DisabledPendingApprovalAt = tmp
			}

		case cn5:
			if c5.Valid {
				if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn6:
			if c6.Valid {
				if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
					return err
				} else {
					i.SessionWatermark = uid.String()
				}
			}

		case cn7:
			if c7.Valid {
				tmp := c7.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t profileScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t profileScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t profileScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// DaemonScanner scanner interface.
type DaemonScanner interface {
	Scan(i *Daemon) error
	Next() bool
	Close() error
	Err() error
}

type errDaemonScanner struct {
	e error
}

func (t errDaemonScanner) Scan(i *Daemon) error {
	return t.e
}

func (t errDaemonScanner) Next() bool {
	return false
}

func (t errDaemonScanner) Err() error {
	return t.e
}

func (t errDaemonScanner) Close() error {
	return nil
}

// DaemonScannerStaticColumns generated by genieql
const DaemonScannerStaticColumns = `meta_daemons."created_at",meta_daemons."description",meta_daemons."hostname",meta_daemons."id",meta_daemons."updated_at"`

// NewDaemonScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewDaemonScannerStatic(rows *sql.Rows, err error) DaemonScanner {
	if err != nil {
		return errDaemonScanner{e: err}
	}

	return daemonScannerStatic{
		Rows: rows,
	}
}

// daemonScannerStatic generated by genieql
type daemonScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t daemonScannerStatic) Scan(i *Daemon) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.Hostname = tmp
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c4.Valid {
		tmp := c4.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t daemonScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t daemonScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t daemonScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewDaemonScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewDaemonScannerStaticRow(row *sql.Row) DaemonScannerStaticRow {
	return DaemonScannerStaticRow{
		row: row,
	}
}

// DaemonScannerStaticRow generated by genieql
type DaemonScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t DaemonScannerStaticRow) Scan(i *Daemon) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.Hostname = tmp
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c4.Valid {
		tmp := c4.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t DaemonScannerStaticRow) Err(err error) DaemonScannerStaticRow {
	t.err = err
	return t
}

// NewDaemonScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewDaemonScannerDynamic(rows *sql.Rows, err error) DaemonScanner {
	if err != nil {
		return errDaemonScanner{e: err}
	}

	return daemonScannerDynamic{
		Rows: rows,
	}
}

// daemonScannerDynamic generated by genieql
type daemonScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t daemonScannerDynamic) Scan(i *Daemon) error {
	const (
		cn0 = "created_at"
		cn1 = "description"
		cn2 = "hostname"
		cn3 = "id"
		cn4 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullString
		c2      sql.NullString
		c3      sql.NullString
		c4      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				i.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.Description = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := string(c2.String)
				i.Hostname = tmp
			}

		case cn3:
			if c3.Valid {
				if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn4:
			if c4.Valid {
				tmp := c4.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t daemonScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t daemonScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t daemonScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ConsumedTokenScanner scanner interface.
type ConsumedTokenScanner interface {
	Scan(a *ConsumedToken) error
	Next() bool
	Close() error
	Err() error
}

type errConsumedTokenScanner struct {
	e error
}

func (t errConsumedTokenScanner) Scan(a *ConsumedToken) error {
	return t.e
}

func (t errConsumedTokenScanner) Next() bool {
	return false
}

func (t errConsumedTokenScanner) Err() error {
	return t.e
}

func (t errConsumedTokenScanner) Close() error {
	return nil
}

// ConsumedTokenScannerStaticColumns generated by genieql
const ConsumedTokenScannerStaticColumns = `meta_consumed_tokens."created_at",meta_consumed_tokens."id",meta_consumed_tokens."token",meta_consumed_tokens."tombstoned_at"`

// NewConsumedTokenScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewConsumedTokenScannerStatic(rows *sql.Rows, err error) ConsumedTokenScanner {
	if err != nil {
		return errConsumedTokenScanner{e: err}
	}

	return consumedTokenScannerStatic{
		Rows: rows,
	}
}

// consumedTokenScannerStatic generated by genieql
type consumedTokenScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t consumedTokenScannerStatic) Scan(a *ConsumedToken) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		a.CreatedAt = tmp
	}

	if c1.Valid {
		if uid, err := uuid.FromBytes([]byte(c1.String)); err != nil {
			return err
		} else {
			a.ID = uid.String()
		}
	}

	if c2.Valid {
		tmp := string(c2.String)
		a.Token = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		a.TombstonedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t consumedTokenScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t consumedTokenScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t consumedTokenScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewConsumedTokenScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewConsumedTokenScannerStaticRow(row *sql.Row) ConsumedTokenScannerStaticRow {
	return ConsumedTokenScannerStaticRow{
		row: row,
	}
}

// ConsumedTokenScannerStaticRow generated by genieql
type ConsumedTokenScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ConsumedTokenScannerStaticRow) Scan(a *ConsumedToken) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		a.CreatedAt = tmp
	}

	if c1.Valid {
		if uid, err := uuid.FromBytes([]byte(c1.String)); err != nil {
			return err
		} else {
			a.ID = uid.String()
		}
	}

	if c2.Valid {
		tmp := string(c2.String)
		a.Token = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		a.TombstonedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t ConsumedTokenScannerStaticRow) Err(err error) ConsumedTokenScannerStaticRow {
	t.err = err
	return t
}

// NewConsumedTokenScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewConsumedTokenScannerDynamic(rows *sql.Rows, err error) ConsumedTokenScanner {
	if err != nil {
		return errConsumedTokenScanner{e: err}
	}

	return consumedTokenScannerDynamic{
		Rows: rows,
	}
}

// consumedTokenScannerDynamic generated by genieql
type consumedTokenScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t consumedTokenScannerDynamic) Scan(a *ConsumedToken) error {
	const (
		cn0 = "created_at"
		cn1 = "id"
		cn2 = "token"
		cn3 = "tombstoned_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullString
		c2      sql.NullString
		c3      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				a.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				if uid, err := uuid.FromBytes([]byte(c1.String)); err != nil {
					return err
				} else {
					a.ID = uid.String()
				}
			}

		case cn2:
			if c2.Valid {
				tmp := string(c2.String)
				a.Token = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				a.TombstonedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t consumedTokenScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t consumedTokenScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t consumedTokenScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// AuthzScanner scanner interface.
type AuthzScanner interface {
	Scan(a *Authz) error
	Next() bool
	Close() error
	Err() error
}

type errAuthzScanner struct {
	e error
}

func (t errAuthzScanner) Scan(a *Authz) error {
	return t.e
}

func (t errAuthzScanner) Next() bool {
	return false
}

func (t errAuthzScanner) Err() error {
	return t.e
}

func (t errAuthzScanner) Close() error {
	return nil
}

// AuthzScannerStaticColumns generated by genieql
const AuthzScannerStaticColumns = `authz_meta."created_at",authz_meta."id",authz_meta."profile_id",authz_meta."updated_at",authz_meta."usermanagement"`

// NewAuthzScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewAuthzScannerStatic(rows *sql.Rows, err error) AuthzScanner {
	if err != nil {
		return errAuthzScanner{e: err}
	}

	return authzScannerStatic{
		Rows: rows,
	}
}

// authzScannerStatic generated by genieql
type authzScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t authzScannerStatic) Scan(a *Authz) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullTime
		c4 sql.NullBool
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		a.CreatedAt = tmp
	}

	if c1.Valid {
		if uid, err := uuid.FromBytes([]byte(c1.String)); err != nil {
			return err
		} else {
			a.ID = uid.String()
		}
	}

	if c2.Valid {
		if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
			return err
		} else {
			a.ProfileID = uid.String()
		}
	}

	if c3.Valid {
		tmp := c3.Time
		a.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.Bool
		a.Usermanagement = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t authzScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t authzScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t authzScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewAuthzScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewAuthzScannerStaticRow(row *sql.Row) AuthzScannerStaticRow {
	return AuthzScannerStaticRow{
		row: row,
	}
}

// AuthzScannerStaticRow generated by genieql
type AuthzScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t AuthzScannerStaticRow) Scan(a *Authz) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullTime
		c4 sql.NullBool
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		a.CreatedAt = tmp
	}

	if c1.Valid {
		if uid, err := uuid.FromBytes([]byte(c1.String)); err != nil {
			return err
		} else {
			a.ID = uid.String()
		}
	}

	if c2.Valid {
		if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
			return err
		} else {
			a.ProfileID = uid.String()
		}
	}

	if c3.Valid {
		tmp := c3.Time
		a.UpdatedAt = tmp
	}

	if c4.Valid {
		tmp := c4.Bool
		a.Usermanagement = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t AuthzScannerStaticRow) Err(err error) AuthzScannerStaticRow {
	t.err = err
	return t
}

// NewAuthzScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewAuthzScannerDynamic(rows *sql.Rows, err error) AuthzScanner {
	if err != nil {
		return errAuthzScanner{e: err}
	}

	return authzScannerDynamic{
		Rows: rows,
	}
}

// authzScannerDynamic generated by genieql
type authzScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t authzScannerDynamic) Scan(a *Authz) error {
	const (
		cn0 = "created_at"
		cn1 = "id"
		cn2 = "profile_id"
		cn3 = "updated_at"
		cn4 = "usermanagement"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullString
		c2      sql.NullString
		c3      sql.NullTime
		c4      sql.NullBool
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				a.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				if uid, err := uuid.FromBytes([]byte(c1.String)); err != nil {
					return err
				} else {
					a.ID = uid.String()
				}
			}

		case cn2:
			if c2.Valid {
				if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
					return err
				} else {
					a.ProfileID = uid.String()
				}
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				a.UpdatedAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := c4.Bool
				a.Usermanagement = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t authzScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t authzScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t authzScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ProfileInsertWithDefaultsStaticColumns generated by genieql
const ProfileInsertWithDefaultsStaticColumns = `DEFAULT,$1,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT`

// ProfileInsertWithDefaultsExplode generated by genieql
func ProfileInsertWithDefaultsExplode(a *Profile) ([]interface{}, error) {
	var (
		c0 sql.NullString // description
	)

	c0.Valid = true
	c0.String = a.Description

	return []interface{}{c0}, nil
}

// ProfileInsertWithDefaults generated by genieql
func ProfileInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Profile) ProfileScannerStaticRow {
	const query = `INSERT INTO "meta_profiles" ("created_at","description","disabled_at","disabled_manually_at","disabled_pending_approval_at","id","session_watermark","updated_at") VALUES (DEFAULT,$1,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "created_at","description","disabled_at","disabled_manually_at","disabled_pending_approval_at","id","session_watermark","updated_at"`
	var c0 sql.NullString
	c0.Valid = true
	c0.String = a.Description // description
	return NewProfileScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// ProfileFindByID generated by genieql
func ProfileFindByID(ctx context.Context, q sqlx.Queryer, id string) ProfileScannerStaticRow {
	const query = `SELECT meta_profiles."created_at",meta_profiles."description",meta_profiles."disabled_at",meta_profiles."disabled_manually_at",meta_profiles."disabled_pending_approval_at",meta_profiles."id",meta_profiles."session_watermark",meta_profiles."updated_at" FROM meta_profiles WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewProfileScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// DaemonInsertWithDefaultsStaticColumns generated by genieql
const DaemonInsertWithDefaultsStaticColumns = `DEFAULT,$1,$2,$3,DEFAULT`

// DaemonInsertWithDefaultsExplode generated by genieql
func DaemonInsertWithDefaultsExplode(a *Daemon) ([]interface{}, error) {
	var (
		c0 sql.NullString // description
		c1 sql.NullString // hostname
		c2 sql.NullString // id
	)

	c0.Valid = true
	c0.String = a.Description

	c1.Valid = true
	c1.String = a.Hostname

	c2.Valid = true
	c2.String = a.ID

	return []interface{}{c0, c1, c2}, nil
}

// DaemonInsertWithDefaults generated by genieql
func DaemonInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Daemon) DaemonScannerStaticRow {
	const query = `INSERT INTO "meta_daemons" ("created_at","description","hostname","id","updated_at") VALUES (DEFAULT,$1,$2,$3,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "created_at","description","hostname","id","updated_at"`
	var (
		c0 sql.NullString // description
		c1 sql.NullString // hostname
		c2 sql.NullString
	)
	c0.Valid = true
	c0.String = a.Description
	c1.Valid = true
	c1.String = a.Hostname
	c2.Valid = true
	c2.String = a.ID // id
	return NewDaemonScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}

// DaemonFindByLatestUpdated generated by genieql
func DaemonFindByLatestUpdated(ctx context.Context, q sqlx.Queryer) DaemonScannerStaticRow {
	const query = `SELECT meta_daemons."created_at",meta_daemons."description",meta_daemons."hostname",meta_daemons."id",meta_daemons."updated_at" FROM meta_daemons ORDER BY updated_at DESC LIMIT 1`
	return NewDaemonScannerStaticRow(q.QueryRowContext(ctx, query))
}

// ConsumedTokenFindByCreatedAt generated by genieql
func ConsumedTokenFindByCreatedAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) ConsumedTokenScannerStaticRow {
	const query = `SELECT "created_at","id","token","tombstoned_at" FROM "meta_consumed_tokens" WHERE "created_at" = $1`
	return NewConsumedTokenScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// ConsumedTokenFindByID generated by genieql
func ConsumedTokenFindByID(ctx context.Context, q sqlx.Queryer, c sql.NullString) ConsumedTokenScannerStaticRow {
	const query = `SELECT "created_at","id","token","tombstoned_at" FROM "meta_consumed_tokens" WHERE "id" = $1`
	return NewConsumedTokenScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// ConsumedTokenFindByToken generated by genieql
func ConsumedTokenFindByToken(ctx context.Context, q sqlx.Queryer, c sql.NullString) ConsumedTokenScannerStaticRow {
	const query = `SELECT "created_at","id","token","tombstoned_at" FROM "meta_consumed_tokens" WHERE "token" = $1`
	return NewConsumedTokenScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// ConsumedTokenFindByTombstonedAt generated by genieql
func ConsumedTokenFindByTombstonedAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) ConsumedTokenScannerStaticRow {
	const query = `SELECT "created_at","id","token","tombstoned_at" FROM "meta_consumed_tokens" WHERE "tombstoned_at" = $1`
	return NewConsumedTokenScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// ConsumedTokenInsertWithDefaultsStaticColumns generated by genieql
const ConsumedTokenInsertWithDefaultsStaticColumns = `DEFAULT,$1,$2,$3`

// ConsumedTokenInsertWithDefaultsExplode generated by genieql
func ConsumedTokenInsertWithDefaultsExplode(a *ConsumedToken) ([]interface{}, error) {
	var (
		c0 sql.NullString // id
		c1 sql.NullString // token
		c2 sql.NullTime   // tombstoned_at
	)

	c0.Valid = true
	c0.String = a.ID

	c1.Valid = true
	c1.String = a.Token

	c2.Valid = true
	c2.Time = a.TombstonedAt

	return []interface{}{c0, c1, c2}, nil
}

// ConsumedTokenInsertWithDefaults generated by genieql
func ConsumedTokenInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a ConsumedToken) ConsumedTokenScannerStaticRow {
	const query = `INSERT INTO "meta_consumed_tokens" ("created_at","id","token","tombstoned_at") VALUES (DEFAULT,$1,$2,$3) RETURNING "created_at","id","token","tombstoned_at"`
	var (
		c0 sql.NullString // id
		c1 sql.NullString // token
		c2 sql.NullTime
	)
	c0.Valid = true
	c0.String = a.ID
	c1.Valid = true
	c1.String = a.Token
	c2.Valid = true
	c2.Time = a.TombstonedAt // tombstoned_at
	return NewConsumedTokenScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}

// AuthzFindByCreatedAt generated by genieql
func AuthzFindByCreatedAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) AuthzScannerStaticRow {
	const query = `SELECT "created_at","id","profile_id","updated_at","usermanagement" FROM "authz_meta" WHERE "created_at" = $1`
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// AuthzFindByID generated by genieql
func AuthzFindByID(ctx context.Context, q sqlx.Queryer, c sql.NullString) AuthzScannerStaticRow {
	const query = `SELECT "created_at","id","profile_id","updated_at","usermanagement" FROM "authz_meta" WHERE "id" = $1`
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// AuthzFindByProfileID generated by genieql
func AuthzFindByProfileID(ctx context.Context, q sqlx.Queryer, c sql.NullString) AuthzScannerStaticRow {
	const query = `SELECT "created_at","id","profile_id","updated_at","usermanagement" FROM "authz_meta" WHERE "profile_id" = $1`
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// AuthzFindByUpdatedAt generated by genieql
func AuthzFindByUpdatedAt(ctx context.Context, q sqlx.Queryer, c sql.NullTime) AuthzScannerStaticRow {
	const query = `SELECT "created_at","id","profile_id","updated_at","usermanagement" FROM "authz_meta" WHERE "updated_at" = $1`
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// AuthzFindByUsermanagement generated by genieql
func AuthzFindByUsermanagement(ctx context.Context, q sqlx.Queryer, c sql.NullBool) AuthzScannerStaticRow {
	const query = `SELECT "created_at","id","profile_id","updated_at","usermanagement" FROM "authz_meta" WHERE "usermanagement" = $1`
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c))
}

// AuthzInsertWithDefaultsStaticColumns generated by genieql
const AuthzInsertWithDefaultsStaticColumns = `DEFAULT,DEFAULT,$1,$2,$3`

// AuthzInsertWithDefaultsExplode generated by genieql
func AuthzInsertWithDefaultsExplode(a *Authz) ([]interface{}, error) {
	var (
		c0 sql.NullString // profile_id
		c1 sql.NullTime   // updated_at
		c2 sql.NullBool   // usermanagement
	)

	c0.Valid = true
	c0.String = a.ProfileID

	c1.Valid = true
	c1.Time = a.UpdatedAt

	c2.Valid = true
	c2.Bool = a.Usermanagement

	return []interface{}{c0, c1, c2}, nil
}

// AuthzInsertWithDefaults generated by genieql
func AuthzInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Authz) AuthzScannerStaticRow {
	const query = `INSERT INTO "authz_meta" ("created_at","id","profile_id","updated_at","usermanagement") VALUES (DEFAULT,DEFAULT,$1,$2,$3) RETURNING "created_at","id","profile_id","updated_at","usermanagement"`
	var (
		c0 sql.NullString // profile_id
		c1 sql.NullTime   // updated_at
		c2 sql.NullBool
	)
	c0.Valid = true
	c0.String = a.ProfileID
	c1.Valid = true
	c1.Time = a.UpdatedAt
	c2.Valid = true
	c2.Bool = a.Usermanagement // usermanagement
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}

// AuthzUpsertWithDefaultsStaticColumns generated by genieql
const AuthzUpsertWithDefaultsStaticColumns = `DEFAULT,DEFAULT,$1,DEFAULT,$2`

// AuthzUpsertWithDefaultsExplode generated by genieql
func AuthzUpsertWithDefaultsExplode(p *Authz) ([]interface{}, error) {
	var (
		c0 sql.NullString // profile_id
		c1 sql.NullBool   // usermanagement
	)

	c0.Valid = true
	c0.String = p.ProfileID

	c1.Valid = true
	c1.Bool = p.Usermanagement

	return []interface{}{c0, c1}, nil
}

// AuthzUpsertWithDefaults generated by genieql
// upsert a single record with default fields.
func AuthzUpsertWithDefaults(ctx context.Context, q sqlx.Queryer, p Authz) AuthzScannerStaticRow {
	const query = `INSERT INTO "authz_meta" ("created_at","id","profile_id","updated_at","usermanagement") VALUES (DEFAULT,DEFAULT,$1,DEFAULT,$2) ON CONFLICT (profile_id) DO UPDATE SET usermanagement = EXCLUDED.usermanagement, updated_at = DEFAULT RETURNING "created_at","id","profile_id","updated_at","usermanagement"`
	var (
		c0 sql.NullString // profile_id
		c1 sql.NullBool
	)
	c0.Valid = true
	c0.String = p.ProfileID
	c1.Valid = true
	c1.Bool = p.Usermanagement // usermanagement
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1))
}

// AuthzDeleteByProfileID generated by genieql
func AuthzDeleteByProfileID(ctx context.Context, q sqlx.Queryer, id string) AuthzScannerStaticRow {
	const query = `DELETE FROM authz_meta WHERE profile_id = $1 RETURNING authz_meta."created_at",authz_meta."id",authz_meta."profile_id",authz_meta."updated_at",authz_meta."usermanagement"`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewAuthzScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}
