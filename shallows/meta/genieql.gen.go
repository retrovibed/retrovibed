//go:build !genieql.ignore
// +build !genieql.ignore

package meta

import (
	"context"
	"database/sql"
	"time"

	"github.com/gofrs/uuid"
	"github.com/retrovibed/retrovibed/internal/sqlx"
)

// DO NOT EDIT: This File was auto generated by the following command:
// genieql auto -v -o genieql.gen.go
// invoked by go generate @ meta/10_generate.genieql.go line 3

// Profile generated by genieql
type Profile struct {
	CreatedAt                 time.Time `json:"created_at"`
	Description               string    `json:"description"`
	DisabledAt                time.Time `json:"disabled_at"`
	DisabledManuallyAt        time.Time `json:"disabled_manually_at"`
	DisabledPendingApprovalAt time.Time `json:"disabled_pending_approval_at"`
	ID                        string    `json:"id"`
	SessionWatermark          string    `json:"session_watermark"`
	UpdatedAt                 time.Time `json:"updated_at"`
}

// IdentitySSH generated by genieql
type IdentitySSH struct {
	CreatedAt  time.Time `json:"created_at"`
	DisabledAt time.Time `json:"disabled_at"`
	ID         string    `json:"id"`
	ProfileID  string    `json:"profile_id"`
	PublicKey  string    `json:"public_key"`
	UpdatedAt  time.Time `json:"updated_at"`
}

// Daemon generated by genieql
type Daemon struct {
	CreatedAt   time.Time `json:"created_at"`
	Description string    `json:"description"`
	Hostname    string    `json:"hostname"`
	ID          string    `json:"id"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ProfileScanner scanner interface.
type ProfileScanner interface {
	Scan(i *Profile) error
	Next() bool
	Close() error
	Err() error
}

type errProfileScanner struct {
	e error
}

func (t errProfileScanner) Scan(i *Profile) error {
	return t.e
}

func (t errProfileScanner) Next() bool {
	return false
}

func (t errProfileScanner) Err() error {
	return t.e
}

func (t errProfileScanner) Close() error {
	return nil
}

// ProfileScannerStaticColumns generated by genieql
const ProfileScannerStaticColumns = `meta_profiles."created_at",meta_profiles."description",meta_profiles."disabled_at",meta_profiles."disabled_manually_at",meta_profiles."disabled_pending_approval_at",meta_profiles."id",meta_profiles."session_watermark",meta_profiles."updated_at"`

// NewProfileScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewProfileScannerStatic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerStatic{
		Rows: rows,
	}
}

// profileScannerStatic generated by genieql
type profileScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t profileScannerStatic) Scan(i *Profile) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullTime
		c3 sql.NullTime
		c4 sql.NullTime
		c5 sql.NullString
		c6 sql.NullString
		c7 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := c2.Time
		i.DisabledAt = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.DisabledManuallyAt = tmp
	}

	if c4.Valid {
		tmp := c4.Time
		i.DisabledPendingApprovalAt = tmp
	}

	if c5.Valid {
		if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.SessionWatermark = uid.String()
		}
	}

	if c7.Valid {
		tmp := c7.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t profileScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t profileScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t profileScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewProfileScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewProfileScannerStaticRow(row *sql.Row) ProfileScannerStaticRow {
	return ProfileScannerStaticRow{
		row: row,
	}
}

// ProfileScannerStaticRow generated by genieql
type ProfileScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t ProfileScannerStaticRow) Scan(i *Profile) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullTime
		c3 sql.NullTime
		c4 sql.NullTime
		c5 sql.NullString
		c6 sql.NullString
		c7 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5, &c6, &c7); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := c2.Time
		i.DisabledAt = tmp
	}

	if c3.Valid {
		tmp := c3.Time
		i.DisabledManuallyAt = tmp
	}

	if c4.Valid {
		tmp := c4.Time
		i.DisabledPendingApprovalAt = tmp
	}

	if c5.Valid {
		if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c6.Valid {
		if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
			return err
		} else {
			i.SessionWatermark = uid.String()
		}
	}

	if c7.Valid {
		tmp := c7.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t ProfileScannerStaticRow) Err(err error) ProfileScannerStaticRow {
	t.err = err
	return t
}

// NewProfileScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewProfileScannerDynamic(rows *sql.Rows, err error) ProfileScanner {
	if err != nil {
		return errProfileScanner{e: err}
	}

	return profileScannerDynamic{
		Rows: rows,
	}
}

// profileScannerDynamic generated by genieql
type profileScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t profileScannerDynamic) Scan(i *Profile) error {
	const (
		cn0 = "created_at"
		cn1 = "description"
		cn2 = "disabled_at"
		cn3 = "disabled_manually_at"
		cn4 = "disabled_pending_approval_at"
		cn5 = "id"
		cn6 = "session_watermark"
		cn7 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullString
		c2      sql.NullTime
		c3      sql.NullTime
		c4      sql.NullTime
		c5      sql.NullString
		c6      sql.NullString
		c7      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		case cn6:
			dst = append(dst, &c6)
		case cn7:
			dst = append(dst, &c7)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				i.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.Description = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := c2.Time
				i.DisabledAt = tmp
			}

		case cn3:
			if c3.Valid {
				tmp := c3.Time
				i.DisabledManuallyAt = tmp
			}

		case cn4:
			if c4.Valid {
				tmp := c4.Time
				i.DisabledPendingApprovalAt = tmp
			}

		case cn5:
			if c5.Valid {
				if uid, err := uuid.FromBytes([]byte(c5.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn6:
			if c6.Valid {
				if uid, err := uuid.FromBytes([]byte(c6.String)); err != nil {
					return err
				} else {
					i.SessionWatermark = uid.String()
				}
			}

		case cn7:
			if c7.Valid {
				tmp := c7.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t profileScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t profileScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t profileScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// IdentitySSHScanner scanner interface.
type IdentitySSHScanner interface {
	Scan(i *IdentitySSH) error
	Next() bool
	Close() error
	Err() error
}

type errIdentitySSHScanner struct {
	e error
}

func (t errIdentitySSHScanner) Scan(i *IdentitySSH) error {
	return t.e
}

func (t errIdentitySSHScanner) Next() bool {
	return false
}

func (t errIdentitySSHScanner) Err() error {
	return t.e
}

func (t errIdentitySSHScanner) Close() error {
	return nil
}

// IdentitySSHScannerStaticColumns generated by genieql
const IdentitySSHScannerStaticColumns = `meta_sso_identity_ssh."created_at",meta_sso_identity_ssh."disabled_at",meta_sso_identity_ssh."id",meta_sso_identity_ssh."profile_id",meta_sso_identity_ssh."public_key",meta_sso_identity_ssh."updated_at"`

// NewIdentitySSHScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewIdentitySSHScannerStatic(rows *sql.Rows, err error) IdentitySSHScanner {
	if err != nil {
		return errIdentitySSHScanner{e: err}
	}

	return identitySSHScannerStatic{
		Rows: rows,
	}
}

// identitySSHScannerStatic generated by genieql
type identitySSHScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t identitySSHScannerStatic) Scan(i *IdentitySSH) error {
	var (
		c0 sql.NullTime
		c1 sql.NullTime
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullString
		c5 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4, &c5); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := c1.Time
		i.DisabledAt = tmp
	}

	if c2.Valid {
		if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ProfileID = uid.String()
		}
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.PublicKey = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t identitySSHScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t identitySSHScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t identitySSHScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewIdentitySSHScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewIdentitySSHScannerStaticRow(row *sql.Row) IdentitySSHScannerStaticRow {
	return IdentitySSHScannerStaticRow{
		row: row,
	}
}

// IdentitySSHScannerStaticRow generated by genieql
type IdentitySSHScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t IdentitySSHScannerStaticRow) Scan(i *IdentitySSH) error {
	var (
		c0 sql.NullTime
		c1 sql.NullTime
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullString
		c5 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4, &c5); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := c1.Time
		i.DisabledAt = tmp
	}

	if c2.Valid {
		if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ProfileID = uid.String()
		}
	}

	if c4.Valid {
		tmp := string(c4.String)
		i.PublicKey = tmp
	}

	if c5.Valid {
		tmp := c5.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t IdentitySSHScannerStaticRow) Err(err error) IdentitySSHScannerStaticRow {
	t.err = err
	return t
}

// NewIdentitySSHScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewIdentitySSHScannerDynamic(rows *sql.Rows, err error) IdentitySSHScanner {
	if err != nil {
		return errIdentitySSHScanner{e: err}
	}

	return identitySSHScannerDynamic{
		Rows: rows,
	}
}

// identitySSHScannerDynamic generated by genieql
type identitySSHScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t identitySSHScannerDynamic) Scan(i *IdentitySSH) error {
	const (
		cn0 = "created_at"
		cn1 = "disabled_at"
		cn2 = "id"
		cn3 = "profile_id"
		cn4 = "public_key"
		cn5 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullTime
		c2      sql.NullString
		c3      sql.NullString
		c4      sql.NullString
		c5      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		case cn5:
			dst = append(dst, &c5)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				i.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := c1.Time
				i.DisabledAt = tmp
			}

		case cn2:
			if c2.Valid {
				if uid, err := uuid.FromBytes([]byte(c2.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn3:
			if c3.Valid {
				if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
					return err
				} else {
					i.ProfileID = uid.String()
				}
			}

		case cn4:
			if c4.Valid {
				tmp := string(c4.String)
				i.PublicKey = tmp
			}

		case cn5:
			if c5.Valid {
				tmp := c5.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t identitySSHScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t identitySSHScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t identitySSHScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// DaemonScanner scanner interface.
type DaemonScanner interface {
	Scan(i *Daemon) error
	Next() bool
	Close() error
	Err() error
}

type errDaemonScanner struct {
	e error
}

func (t errDaemonScanner) Scan(i *Daemon) error {
	return t.e
}

func (t errDaemonScanner) Next() bool {
	return false
}

func (t errDaemonScanner) Err() error {
	return t.e
}

func (t errDaemonScanner) Close() error {
	return nil
}

// DaemonScannerStaticColumns generated by genieql
const DaemonScannerStaticColumns = `meta_daemons."created_at",meta_daemons."description",meta_daemons."hostname",meta_daemons."id",meta_daemons."updated_at"`

// NewDaemonScannerStatic creates a scanner that operates on a static
// set of columns that are always returned in the same order.
func NewDaemonScannerStatic(rows *sql.Rows, err error) DaemonScanner {
	if err != nil {
		return errDaemonScanner{e: err}
	}

	return daemonScannerStatic{
		Rows: rows,
	}
}

// daemonScannerStatic generated by genieql
type daemonScannerStatic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t daemonScannerStatic) Scan(i *Daemon) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullTime
	)

	if err := t.Rows.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.Hostname = tmp
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c4.Valid {
		tmp := c4.Time
		i.UpdatedAt = tmp
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t daemonScannerStatic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t daemonScannerStatic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t daemonScannerStatic) Next() bool {
	return t.Rows.Next()
}

// NewDaemonScannerStaticRow creates a scanner that operates on a static
// set of columns that are always returned in the same order, only scans a single row.
func NewDaemonScannerStaticRow(row *sql.Row) DaemonScannerStaticRow {
	return DaemonScannerStaticRow{
		row: row,
	}
}

// DaemonScannerStaticRow generated by genieql
type DaemonScannerStaticRow struct {
	err error
	row *sql.Row
}

// Scan generated by genieql
func (t DaemonScannerStaticRow) Scan(i *Daemon) error {
	var (
		c0 sql.NullTime
		c1 sql.NullString
		c2 sql.NullString
		c3 sql.NullString
		c4 sql.NullTime
	)

	if t.err != nil {
		return t.err
	}

	if err := t.row.Scan(&c0, &c1, &c2, &c3, &c4); err != nil {
		return err
	}

	if c0.Valid {
		tmp := c0.Time
		i.CreatedAt = tmp
	}

	if c1.Valid {
		tmp := string(c1.String)
		i.Description = tmp
	}

	if c2.Valid {
		tmp := string(c2.String)
		i.Hostname = tmp
	}

	if c3.Valid {
		if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
			return err
		} else {
			i.ID = uid.String()
		}
	}

	if c4.Valid {
		tmp := c4.Time
		i.UpdatedAt = tmp
	}

	return nil
}

// Err set an error to return by scan
func (t DaemonScannerStaticRow) Err(err error) DaemonScannerStaticRow {
	t.err = err
	return t
}

// NewDaemonScannerDynamic creates a scanner that operates on a dynamic
// set of columns that can be returned in any subset/order.
func NewDaemonScannerDynamic(rows *sql.Rows, err error) DaemonScanner {
	if err != nil {
		return errDaemonScanner{e: err}
	}

	return daemonScannerDynamic{
		Rows: rows,
	}
}

// daemonScannerDynamic generated by genieql
type daemonScannerDynamic struct {
	Rows *sql.Rows `json:"rows"`
}

// Scan generated by genieql
func (t daemonScannerDynamic) Scan(i *Daemon) error {
	const (
		cn0 = "created_at"
		cn1 = "description"
		cn2 = "hostname"
		cn3 = "id"
		cn4 = "updated_at"
	)
	var (
		ignored sql.RawBytes
		err     error
		columns []string
		dst     []interface{}
		c0      sql.NullTime
		c1      sql.NullString
		c2      sql.NullString
		c3      sql.NullString
		c4      sql.NullTime
	)

	if columns, err = t.Rows.Columns(); err != nil {
		return err
	}

	dst = make([]interface{}, 0, len(columns))

	for _, column := range columns {
		switch column {
		case cn0:
			dst = append(dst, &c0)
		case cn1:
			dst = append(dst, &c1)
		case cn2:
			dst = append(dst, &c2)
		case cn3:
			dst = append(dst, &c3)
		case cn4:
			dst = append(dst, &c4)
		default:
			dst = append(dst, &ignored)
		}
	}

	if err := t.Rows.Scan(dst...); err != nil {
		return err
	}

	for _, column := range columns {
		switch column {
		case cn0:
			if c0.Valid {
				tmp := c0.Time
				i.CreatedAt = tmp
			}

		case cn1:
			if c1.Valid {
				tmp := string(c1.String)
				i.Description = tmp
			}

		case cn2:
			if c2.Valid {
				tmp := string(c2.String)
				i.Hostname = tmp
			}

		case cn3:
			if c3.Valid {
				if uid, err := uuid.FromBytes([]byte(c3.String)); err != nil {
					return err
				} else {
					i.ID = uid.String()
				}
			}

		case cn4:
			if c4.Valid {
				tmp := c4.Time
				i.UpdatedAt = tmp
			}

		}
	}

	return t.Rows.Err()
}

// Err generated by genieql
func (t daemonScannerDynamic) Err() error {
	return t.Rows.Err()
}

// Close generated by genieql
func (t daemonScannerDynamic) Close() error {
	if t.Rows == nil {
		return nil
	}
	return t.Rows.Close()
}

// Next generated by genieql
func (t daemonScannerDynamic) Next() bool {
	return t.Rows.Next()
}

// ProfileInsertWithDefaultsStaticColumns generated by genieql
const ProfileInsertWithDefaultsStaticColumns = `DEFAULT,$1,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT`

// ProfileInsertWithDefaultsExplode generated by genieql
func ProfileInsertWithDefaultsExplode(a *Profile) ([]interface{}, error) {
	var (
		c0 sql.NullString // description
	)

	c0.Valid = true
	c0.String = a.Description

	return []interface{}{c0}, nil
}

// ProfileInsertWithDefaults generated by genieql
func ProfileInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Profile) ProfileScannerStaticRow {
	const query = `INSERT INTO "meta_profiles" ("created_at","description","disabled_at","disabled_manually_at","disabled_pending_approval_at","id","session_watermark","updated_at") VALUES (DEFAULT,$1,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "created_at","description","disabled_at","disabled_manually_at","disabled_pending_approval_at","id","session_watermark","updated_at"`
	var c0 sql.NullString
	c0.Valid = true
	c0.String = a.Description // description
	return NewProfileScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// ProfileFindByID generated by genieql
func ProfileFindByID(ctx context.Context, q sqlx.Queryer, id string) ProfileScannerStaticRow {
	const query = `SELECT meta_profiles."created_at",meta_profiles."description",meta_profiles."disabled_at",meta_profiles."disabled_manually_at",meta_profiles."disabled_pending_approval_at",meta_profiles."id",meta_profiles."session_watermark",meta_profiles."updated_at" FROM meta_profiles WHERE "id" = $1`
	var c0 sql.NullString // id
	c0.Valid = true
	c0.String = id
	return NewProfileScannerStaticRow(q.QueryRowContext(ctx, query, c0))
}

// IdentitySSHInsertWithDefaultsStaticColumns generated by genieql
const IdentitySSHInsertWithDefaultsStaticColumns = `DEFAULT,$1,$2,$3,$4,DEFAULT`

// IdentitySSHInsertWithDefaultsExplode generated by genieql
func IdentitySSHInsertWithDefaultsExplode(a *IdentitySSH) ([]interface{}, error) {
	var (
		c0 sql.NullTime   // disabled_at
		c1 sql.NullString // id
		c2 sql.NullString // profile_id
		c3 sql.NullString // public_key
	)

	c0.Valid = true
	c0.Time = a.DisabledAt

	c1.Valid = true
	c1.String = a.ID

	c2.Valid = true
	c2.String = a.ProfileID

	c3.Valid = true
	c3.String = a.PublicKey

	return []interface{}{c0, c1, c2, c3}, nil
}

// IdentitySSHInsertWithDefaults generated by genieql
func IdentitySSHInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a IdentitySSH) IdentitySSHScannerStaticRow {
	const query = `INSERT INTO "meta_sso_identity_ssh" ("created_at","disabled_at","id","profile_id","public_key","updated_at") VALUES (DEFAULT,$1,$2,$3,$4,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "created_at","disabled_at","id","profile_id","public_key","updated_at"`
	var (
		c0 sql.NullTime   // disabled_at
		c1 sql.NullString // id
		c2 sql.NullString // profile_id
		c3 sql.NullString
	)
	c0.Valid = true
	c0.Time = a.DisabledAt
	c1.Valid = true
	c1.String = a.ID
	c2.Valid = true
	c2.String = a.ProfileID
	c3.Valid = true
	c3.String = a.PublicKey // public_key
	return NewIdentitySSHScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2, c3))
}

// DaemonInsertWithDefaultsStaticColumns generated by genieql
const DaemonInsertWithDefaultsStaticColumns = `DEFAULT,$1,$2,$3,DEFAULT`

// DaemonInsertWithDefaultsExplode generated by genieql
func DaemonInsertWithDefaultsExplode(a *Daemon) ([]interface{}, error) {
	var (
		c0 sql.NullString // description
		c1 sql.NullString // hostname
		c2 sql.NullString // id
	)

	c0.Valid = true
	c0.String = a.Description

	c1.Valid = true
	c1.String = a.Hostname

	c2.Valid = true
	c2.String = a.ID

	return []interface{}{c0, c1, c2}, nil
}

// DaemonInsertWithDefaults generated by genieql
func DaemonInsertWithDefaults(ctx context.Context, q sqlx.Queryer, a Daemon) DaemonScannerStaticRow {
	const query = `INSERT INTO "meta_daemons" ("created_at","description","hostname","id","updated_at") VALUES (DEFAULT,$1,$2,$3,DEFAULT) ON CONFLICT (id) DO UPDATE SET updated_at = DEFAULT RETURNING "created_at","description","hostname","id","updated_at"`
	var (
		c0 sql.NullString // description
		c1 sql.NullString // hostname
		c2 sql.NullString
	)
	c0.Valid = true
	c0.String = a.Description
	c1.Valid = true
	c1.String = a.Hostname
	c2.Valid = true
	c2.String = a.ID // id
	return NewDaemonScannerStaticRow(q.QueryRowContext(ctx, query, c0, c1, c2))
}
