// Package genieql generates code to interact with a database.
package genieql

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/james-lawrence/genieql/internal/errorsx"
	"golang.org/x/mod/modfile"
)

// Generators generate schema and configuration for testing.
//go:generate dropdb --if-exists -U postgres genieql_test_template
//go:generate createdb -U postgres genieql_test_template
//go:generate psql -X -1 -f .migrations/postgresql/structure.sql genieql_test_template
//go:generate genieql bootstrap --queryer=sqlx.Queryer --driver=github.com/jackc/pgx postgres://$USER@localhost:5432/genieql_test_template?sslmode=disable
//go:generate genieql bootstrap --queryer=sqlx.Queryer --driver=github.com/jackc/pgx --output-file=generators-test.config postgres://$USER@localhost:5432/genieql_test_template?sslmode=disable
//go:generate genieql bootstrap --queryer=sqlx.Queryer --driver=github.com/marcboeker/go-duckdb --output-file=duckdb.test.config duckdb://localhost/duckdb.test.db

// Build Tag constants
const (
	BuildTagIgnore   = "genieql.ignore"   // used to filter out files from the build context using !genieql.ignore
	BuildTagGenerate = "genieql.generate" // used to specify which files should be analyzed for directives using genieql.generate
)

// Preface text inserted at the top of all generated files.
const Preface = `

// DO NOT EDIT: This File was auto generated by the following command:
// genieql %s
`

// ConfigurationDirectory determines the configuration directory based on the
// go environment.
func ConfigurationDirectory() string {
	var (
		err         error
		defaultPath string
	)

	if defaultPath, err = FindModuleRoot("."); err == nil && defaultPath != "" {
		return filepath.Join(defaultPath, ".genieql")
	}

	paths := filepath.SplitList(os.Getenv("GOPATH"))

	if len(paths) == 0 {
		if defaultPath, err = os.Getwd(); err != nil {
			log.Fatalln(err)
		}
	} else {
		defaultPath = paths[0]
	}

	return filepath.Join(defaultPath, ".genieql")
}

// PrintColumnInfo ...
func PrintColumnInfo(columns ...ColumnInfo) {
	for _, column := range columns {
		log.Println(column)
	}
}

func FindModulePath(dir string) (ipath string, err error) {
	var (
		mroot string
		gmod  []byte
	)

	if mroot, err = FindModuleRoot(dir); err != nil {
		return "", err
	}

	if gmod, err = os.ReadFile(filepath.Join(mroot, "go.mod")); err != nil {
		return "", err
	}

	if ipath = modfile.ModulePath(gmod); ipath == "" {
		return "", fmt.Errorf("unable to determine module path")
	}

	return ipath, nil
}

// FindModuleRoot pulled from: https://github.com/golang/go/blob/src/cmd/dist/build.go#L1595
func FindModuleRoot(dir string) (cleaned string, err error) {
	if dir == "" {
		return "", errorsx.New("cannot located go.mod from a blank directory path")
	}

	if cleaned, err = filepath.Abs(filepath.Clean(dir)); err != nil {
		return "", errorsx.Wrap(err, "failed to determined absolute path to directory")
	}

	// Look for enclosing go.mod.
	for {
		gomod := filepath.Join(cleaned, "go.mod")
		if fi, err := os.Stat(gomod); err == nil && !fi.IsDir() {
			return cleaned, nil
		}

		d := filepath.Dir(cleaned)

		if d == cleaned {
			break
		}

		cleaned = d
	}

	return "", errorsx.Errorf("go.mod not found: %s", dir)
}
